<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>k-template搭建心得-追梦子</title>
  <link rel="stylesheet" href="/css/reset.css">
  <link rel="stylesheet" href="/css/markdown.css">
  <link rel="stylesheet" href="/css/monokai-sublime.css">
  <link rel="stylesheet" href="/css/info.css">
</head>
<body>
  <div class="box">
    <header>
      <h1 data-pc>k-template搭建心得</h1>
    </header>
    <main class="markdown-body">
      <h2 id="-">实现思路</h2>
<p>搭建一份基础模板,新建项目只需将此模板复制一份</p>
<h2 id="-">实现过程</h2>
<p>添加webpack配置和常用loader,让项目可以跑起来</p>
<h3 id="-">提取开发环境和生产环境公共代码,对于公共的代码尽量保持只有一份,防止以后更改配置时,忘记修改其他文件</h3>
<p>使用webpack-merge合并公共部分</p>
<h3 id="-">解决不同环境下的配置问题</h3>
<p>一开始实现的时候提供了两份模板,一份开发环境的,一份生产环境的,但是后来觉得根本没有必要提供两份模板,因为开发环境和生产环境的区分往往只是参数跟环境的区别,基础部分是不会变的,我们没有必要因为环境的区别而写两份模板,写两份模板的缺点在于当你需要修改基础部分的代码时,需要同时修改多份模板,而我认为对于公共的代码保持一份是最好的</p>
<p>因为只有一份模板,因此需要提供一个根据环境来嵌入不同的js和css的方法</p>
<p><img src="/uploads/5a225fad65201b5f70.png" title="" alt="image" ondblclick="window.open('/uploads/5a225fad65201b5f70.png');"></p>
<ul>
<li>然而这些嵌入的脚本放在前面还是后面?<ul>
<li>由于用户可能会有不同的需求,放在前面后面都有可能,所以我提供了两个不同的配置</li>
<li><code class="javascript"><pre><span class="hljs-comment">// 放在打包文件之前</span>
beforeInject: {
},
<span class="hljs-comment">// 放在打包文件之后</span>
afterInject: {
},
<span class="hljs-attr">env</span>: {
<span class="hljs-attr">dev</span>: {
<span class="hljs-attr">beforeInject</span>: {
  <span class="hljs-attr">css</span>: [],
  <span class="hljs-attr">js</span>: []
}
}
}</pre></code></li>
</ul>
</li>
</ul>
<h3 id="-">实现多页面应用</h3>
<p>最开始的做法是,弄一份公共的模板文件,然后去遍历entry入口,每个key作为一个html文件,而html的内容通过读取模板文件获取</p>
<p><img src="/uploads/5a225edab4e75467f0.png" title="" alt="image" ondblclick="window.open('/uploads/5a225edab4e75467f0.png');"></p>
<p>但后来我发现通过这种方式来实现有一个比较大的缺陷,就是没办法对每个页面单独配置,而以上的这种实现方式会把另一个页面不需要用的数据也给引入进去,我们不能说A页面用到了React,B页面就一定会用到React,所以从本质上来讲以上的实现方式并不能实现真正意义上的多页面应用,真正的多页应用应该是能够对不同页面做不同的处理的</p>
<ul>
<li>如果要做多页面应用,就只能是用户自己提供多个html文件,目前我理想的解决方案是<ul>
<li><code class="javascript"><pre><span class="hljs-comment">// 多页面解决方案</span>
entry: {
<span class="hljs-comment">// 读取./src下的所有js文件作为多入口, 使用默认模板</span>
<span class="hljs-string">'__entry'</span>: <span class="hljs-string">'./src'</span> || [<span class="hljs-string">'./src'</span>, <span class="hljs-string">'./src/js'</span>, <span class="hljs-string">'./src/hot/a.js'</span>],
<span class="hljs-comment">// 单独设置about页</span>
<span class="hljs-string">'./src/about.js'</span>: {
<span class="hljs-comment">// 当不设置template时使用默认的模板文件</span>
template: <span class="hljs-string">'src/about.html'</span>,
<span class="hljs-comment">// 默认引用dll打包文件,设置false则不引用,也可以根据当前页设置所需的</span>
dll: <span class="hljs-literal">false</span> || [<span class="hljs-string">'react'</span>, <span class="hljs-string">'react-router'</span>]
}
}</pre></code></li>
</ul>
</li>
</ul>
<h3 id="-dll-">使用dll打包依赖库,提升构建速度</h3>
<ul>
<li>什么是dll<ul>
<li>一个dll包就是一个纯粹的依赖库，它本身不能运行，是用来给项目引用的。</li>
<li>一个dll包只要它包含的库没有更新,内容也不会发生变化,因此发版时如果dll包没有更新会继续走缓存</li>
<li>打包dll之后,webpack就不需要每次解析dll部分的代码了,这样可以提升很大编译速度</li>
</ul>
</li>
<li>对dll配置的优化<ul>
<li>动态配置需要打包的库,通过读取package.json中的dependencies字段, 这样就不需要手动来配置了</li>
<li><img src="/uploads/5a2265cd63ab72b9ff.png" title="" alt="image" ondblclick="window.open('/uploads/5a2265cd63ab72b9ff.png');"></li>
<li>如果是多页面应用还需要再改动一下,如果用户传递了则使用用户的配置</li>
</ul>
</li>
<li>由于依赖包可能会更新,因此当依赖更新时,用户得手动执行一次打包命令,不然dll中的代码还是旧的<ul>
<li>为了解决手动打包的问题,我将package.json单独保存了一份,每次执行代码之前先检测一次当前package.json中的线上依赖跟上一次保存的是否一致,如果不一致则重新打包</li>
<li><img src="/uploads/5a22689111dc2ccc46.png" title="" alt="image" ondblclick="window.open('/uploads/5a22689111dc2ccc46.png');"></li>
</ul>
</li>
</ul>
<h3 id="-">自动帮用户安装依赖</h3>
<p>当执行yarn start时会先去执行install脚本,判断是否安装过依赖</p>
<p>通过读取node_modules中的目录名跟npm package.json中的线上依赖和开发依赖名称对比,如果发现缺少相关目录名则认为需要安装依赖</p>
<p><img src="/uploads/5a226c10a762562fa7.png" title="" alt="image" ondblclick="window.open('/uploads/5a226c10a762562fa7.png');"></p>
<p><img src="/uploads/5a226b5beca1c8d89c.png" title="" alt="image" ondblclick="window.open('/uploads/5a226b5beca1c8d89c.png');"></p>
<h3 id="-">自动打开浏览器</h3>
<p>openbrowser</p>
<h3 id="-">检查端口是否被占用,如果被占用则使用其他端口</h3>
<p>思路: 先开启一个服务看是否成功,如果失败则将端口加1,再次尝试,如此往返</p>
<p><img src="/uploads/5a226e9ce9bb1c0942.png" title="" alt="image" ondblclick="window.open('/uploads/5a226e9ce9bb1c0942.png');"></p>
<h3 id="-">开发环境</h3>
<p>css,js文件自动加时间戳</p>
<ul>
<li>修改配置文件重启node<ul>
<li>node-dev</li>
</ul>
</li>
<li>把localhost换成局域网ip<ul>
<li>方便移动端调试</li>
</ul>
</li>
</ul>
<h3 id="-">生产环境</h3>
<ul>
<li>使用hash还是chunkhash<ul>
<li>hash: 基于编译计算出的hash<ul>
<li>hash的问题在于当项目中有任何一个文件变化时,就会被重新计算,因此浏览器之前的缓存也会全部失效</li>
</ul>
</li>
<li>chunkhash: chunk内容的hash<ul>
<li>通过每个模块内容计算出的hash</li>
<li>看起来chunkhash是个不错的选择,但问题在于当我们将css代码单独提取到一个文件中的时候,只要我们修改了js或css,两者的chunkhash都会变,原因在于webpack将style视为js的一部分，所以在计算chunkhash时，会把所有的js代码和style代码混合在一起计算。</li>
<li>解决方案使用webpack-md5-hash插件,它会将js和css chunkhash分开计算</li>
</ul>
</li>
<li><a href="http://www.cnblogs.com/ihardcoder/p/5623411.html" title="" target="_blank">Webpack中hash与chunkhash的区别，以及js与css的hash指纹解耦方案</a></li>
</ul>
</li>
<li>每次构建之前先清空目录,因为之前构建的文件就没用了<ul>
<li>注意不能把.git配置删除</li>
</ul>
</li>
<li>支持生产环境起服务<ul>
<li>实现思路,编译后,将打包的目录当成静态资源,起一个服务</li>
</ul>
</li>
</ul>
<h3 id="mock-">mock数据</h3>
<p><img src="/uploads/5a228101e4ee26c8c6.png" title="" alt="image" ondblclick="window.open('/uploads/5a228101e4ee26c8c6.png');"></p>
<p>通过koa-router实现</p>
<p><img src="/uploads/5a22803e97fc5084fe.png" title="" alt="image" ondblclick="window.open('/uploads/5a22803e97fc5084fe.png');"></p>
<h3 id="-">版本控制</h3>
<ul>
<li>ABC 0.0.0<ul>
<li>A: 当你做了不兼容的 API 修改</li>
<li>B: 当你做了向下兼容的功能性新增</li>
<li>C: 当你做了向下兼容的问题修正</li>
</ul>
</li>
<li>修饰词<ul>
<li>先行版本号及版本编译信息可以加到“主版本号.次版本号.修订号”的后面，作为延伸。</li>
<li>alpha: 内部版</li>
<li>beta: 测试版</li>
<li>rc: 正式版</li>
<li>lts: 长期维护</li>
</ul>
</li>
<li>如何确定版本号<ul>
<li>在开发阶段从0.1.0开始,正式发布从1.0.0开始</li>
<li>修改A版本时,BC清零,修改B时C清零</li>
</ul>
</li>
<li>参考<ul>
<li><a href="https://semver.org/lang/zh-CN/" title="" target="_blank">语义化版本</a></li>
</ul>
</li>
</ul>
<h3 id="-tag-release">打tag和release</h3>
<p>对某一时间点上的版本打标签,这样用户可以根据标签来下载不同的版本</p>
<p>release跟tag相似,是github之类的代码管理平台上的东西,它支持添加更多的相关说明</p>
<h3 id="-json-webpack-config-js-">提供JSON 级别的约定型配置还是类似webpack.config.js的编码型配置</h3>
<p><img src="/uploads/5a2285d11d9906278f.png" title="" alt="image" ondblclick="window.open('/uploads/5a2285d11d9906278f.png');"></p>
<p>封装底层架构,其余功能按照插件的形式来配置,只对底层进行升级,其他功能自行升级</p>

    </main>
  </div>
  <script src="/js/init.js"></script>
</body>
</html>
